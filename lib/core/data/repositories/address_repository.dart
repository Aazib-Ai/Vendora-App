import 'package:dartz/dartz.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../config/supabase_config.dart';
import '../../errors/failures.dart';
import '../../../models/address.dart';

abstract class IAddressRepository {
  Future<Either<Failure, List<Address>>> getUserAddresses(String userId);
  Future<Either<Failure, Address>> addAddress(Address address);
  Future<Either<Failure, Address>> updateAddress(Address address);
  Future<Either<Failure, void>> deleteAddress(String addressId);
}

class AddressRepository implements IAddressRepository {
  final SupabaseConfig _supabaseConfig;

  AddressRepository({SupabaseConfig? supabaseConfig})
      : _supabaseConfig = supabaseConfig ?? SupabaseConfig();

  @override
  Future<Either<Failure, List<Address>>> getUserAddresses(String userId) async {
    try {
      final response = await _supabaseConfig
          .from('addresses')
          .select()
          .eq('user_id', userId)
          .order('is_default', ascending: false);

      final addresses = (response as List)
          .map((json) => Address.fromJson(json as Map<String, dynamic>))
          .toList();

      return Right(addresses);
    } on PostgrestException catch (e) {
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }

  @override
  Future<Either<Failure, Address>> addAddress(Address address) async {
    try {
      final addressData = address.toJson();
      addressData.remove('id'); // ID is generated by DB

      // If set as default, unset other defaults
      if (address.isDefault) {
        await _supabaseConfig
            .from('addresses')
            .update({'is_default': false})
            .eq('user_id', address.userId);
      }

      final response = await _supabaseConfig
          .from('addresses')
          .insert(addressData)
          .select()
          .single();

      return Right(Address.fromJson(response));
    } on PostgrestException catch (e) {
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }

  @override
  Future<Either<Failure, Address>> updateAddress(Address address) async {
    try {
      // If set as default, unset other defaults
      if (address.isDefault) {
        await _supabaseConfig
            .from('addresses')
            .update({'is_default': false})
            .eq('user_id', address.userId)
            .neq('id', address.id);
      }

      final addressData = address.toJson();
      addressData.remove('created_at'); // Don't update created_at

      final response = await _supabaseConfig
          .from('addresses')
          .update(addressData)
          .eq('id', address.id)
          .select()
          .single();

      return Right(Address.fromJson(response));
    } on PostgrestException catch (e) {
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }

  @override
  Future<Either<Failure, void>> deleteAddress(String addressId) async {
    try {
      await _supabaseConfig.from('addresses').delete().eq('id', addressId);
      return const Right(null);
    } on PostgrestException catch (e) {
      return Left(ServerFailure(e.message));
    } catch (e) {
      return Left(ServerFailure(e.toString()));
    }
  }
}
